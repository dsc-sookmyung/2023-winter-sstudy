## 객체지향의 개념2

1. 메서드 사용 이유
    - 높은 재사용성
    - 중복된 코드의 제거 : 반복되는 코드 대신 메서드를 호출해 사용, 변경사항 발생 시 관리가 쉽다.
    - 프로그램 구조화 : 규모가 커지면 여러 개의 메서드로 나누어 프로그램의 구조를 단순화
2. JWM의 메모리 구조(3가지 주요 영역) : 프로그램이 실행되면, JVM은 시스템에게 프로그램 실행을 위한 메모리를 할당받고, 이를 용도에 따라 여러 영역으로 나눠 관리한다. 
    - 메서드 영역 : 클래스 파일을 읽어 분석하고, 해당 데이터(클래스의 정보, 클래스변수)를 이곳에 저장한다.
    - 힙 : 인스턴스가 생성되는 공간
    - 호출스택 : 메서드가 호출되었을 때 이를 위한 메모리를 할당하는 공간. 메서드가 종료되면 메모리공간은 반환된다.
3. 클래스 메서드와 인스턴스 메서드
    
    인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는 메서드
    
    클래스 메서드(static)는 인스턴스와 관계없는 없는 메서드
    
    - 클래스 설계시, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
    - 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다. → 클래스가 메모리에 올라갈 때 자동으로 생성된다.
    - 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
4. 클래스 멤버와 인스턴스 멤버간의 참조와 호출
    
    같은 클래스에 있는 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조, 호출이 가능하다. But, 클래스 멤버가 인스턴스 멤버를 참조하고자 할 때는 인스턴스를 생성해야 한다. 
    
    또한, static 메서드에서는 인스턴스 메서드를 호출할 수 없다.
    

### 오버로딩

한 클래스 내에서 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도 매개변수의 갯수, 타입이 다르면 같은 이름으로 메서드를 정의할 수 있다. 

→ 하나의 메서드 이름으로 여러 기능을 구현 가능

- 오버라이딩 조건
    - 메서드 이름이 같아야 한다.
    - 매개변수의 갯수나 타입이 달라야 한다.

### 가변인자와 오버로딩

기존에는 메서드의 매개변수 개수가 고정적이였으나, JDK 1.5부터 동적으로 지정해줄 수 있다.

1. 가변인자를 매개변수로

```java
public PrintStream printf(String format, Object... args) { .. }
```

`“타입… 변수명”` 의 형식으로 지정해주며, 가변인자를 매개변수 중 제일 마지막에 선언해준다. 

가변인자는 내부적으로 배열을 이용하여, 가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성된다. 가변인자를 선언한 메서드는 오버로딩하면 메서드를 호출했을 때 구별하지 못하는 경우가 있기에 되도록 가변인자를 사용한 메서드는 오버로딩하지 않는다. 

1. 매개변수 타입을 배열로

```java
String concatenate(String[] str) { ... }
```

매개변수의 타입을 배열로 하면, 반드시 인자를 지정해줘야 하기에 인자를 생략해서 `concatenate()` 처럼 작성할 수 없는 불편함이 있다.

### 생성자

생성자는 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드이다. 클래스 내에 선언되며, 리턴값이 없다. (void는 생략하고 적지 X)

1. 기본 생성자

클래스에 생성자를 정의하지 않고도 인스턴스를 생성할 수 있느넫, 이는 컴파일러는 기본 생성자를 제공해주기 때문이다. 컴파일러가 자동적으로 추가해주는 기본 생성자는 매개변수와 내용이 아무것도 없는 간단한 생성자이다. 주의할 점은 기본 생성자가 컴파일러에 의해 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다. 

1. 같은 클래스에서 생성자들 간의 호출
    - 생성자간의 호출에는 생성자의 이름이 아니라 this를 호출한다.
    - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
    - this는 참조변수로, this를 통해 인스턴스 변수에 접근할 수 있다. static 메서드에서 인스턴스 메서드를 사용할 수 없는 것처럼, this 또한 사용할 수 없다.

1. 생성자를 이용한 인스턴스의 복사

```java
Car(Car c) {
		color = c.color;
		gearType = c.gearType;
		door = c.door;
}
```

매개변수로 넘겨진 참조변수가 가리키는 Car 인스턴스의 인스턴수 변수인 color, gearType, door의 값을 인스턴스가 자신으로 복사한다. 두 인스턴스는 복사하여 같은 값을 가지지만, 서로 독립적으로 메모리 공간에 존재하는 별도의 인스턴스이기에, 하나의 인스턴스에서 값이 변경되더라도 다른 인스턴스는 영향을 받지 않는다. 

### 변수의 초기화

멤버변수는 초기화하지 않아도 자동으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어지기에 초기화하지 않고 사용 가능하지만, 지역변수는 사용하기 전에 반드시 초기화해야 한다. 

- 멤버변수의 초기화 방법
    1. 명시적 초기화 : 변수를 선언과 동시에 초기화
    2. 생성자
    3. 초기화 블럭
        - 인스턴스 초기화 블럭 : 생성자와 같이 인스턴스를 생성할 때마다 수행
        - 클래스 초기화 블럭 : 클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행
- 초기화 수행 시점
    - 클래스 변수 초기화 시점 : 클래스가 처음 로딩될 때 한번
        - 기본값 → 명시적 초기화 → 클래스 초기화 블럭
    - 인스턴스 변수 : 인스턴스가 생성될 때 인스턴스별로
        - 기본값 → 명시적 초기화 → 인스터스 초기화 블럭 → 생성자

### 상속

기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것으로, 키워드 extends를 사용한다. 

```jsx
class Child extends Parent {
}
```

자손 클래스는 조상 클래스의 모든 멤버를 상속받기에, child 클래스는 parent클래스의 멤버들을 모두 포함한다. 자손 클래스는 항상 조상 클래스보다 같거나 많은 멤버를 갖는다. 

→ 상속을 받는다는 것을 조상 클래스에서 확장(extends)한다는 의미로 해석할 수 있다. 

→ 초기화와 생성자 블럭은 상속되지 않는다. (멤버만 상속됨)
