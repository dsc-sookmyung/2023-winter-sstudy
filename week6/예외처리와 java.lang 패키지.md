### 멀티 Catch 블럭

JDK 1.7부터 여러 catch 블럭을 | 기호를 이용해서 하나의 catch 블럭으로 합칠 수 있게 되었으며, 이를 멀티 catch 블럭이라 한다.

```java
try {
}	catch (ExceptionA e) {
    	e.printStackTrace();
} catch (ExceptionB e) {
    	e.printStackTrace();
}
```

```java
try {
}	catch (ExceptionA | ExceptionB e) {
    	e.printStackTrace();
}
```

만약 멀티 catch블럭의 | 기호로 연결된 예외 클래스가 조상과 자손의 관계에 있다면 컴파일 에러가 발생한다. 멀티 catch는 하나의 catch블럭으로 여러 예외를 처리하는 것이기 때문에, 멀티 catch블럭 내에서는 실제로 어떤 예외가 발생한 것인지 알 수 없다. 그래서 참조변수 e로 멀티 catch블럭에 | 기호로 연결된 예외 클래스들의 공통 분모인 조상 예외 클래스에 선언된 멤버만 사용할 수 있다.

### **예외 발생시키기**

키워드 throw를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있다. 

1. 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든다.

Exception e = new Exception("고의로 발생시켰음");

2. 키워드 throw를 이용해서 예외를 발생시킨다.

throw e;

- unchecked예외 - 컴파일러가 예외처리를 확인하지 않는 RuntimeException클래스들
- checked예외 - 예외처리를 확인하는 Exception클래스들

```java
void method() throws Exception1, Exception2, ... ExceptionN {
	//메서드의 내용
}
```

메서드에 예외를 선언하려면, 메서드의 선언부에 키워드 throws를 사용해서 메서드 내에서 발생할 수 있는 예외를 적어준다. (예외가 여러 개일 경우 쉼표로 구분)

### **자동 자원 반환 - try-with-resources문**

JDK1.7부터 try-with-resources문이라는 try-catch문의 변형이 새로 추가되었다.

주로 입출력에 사용되는 클래스 중에서는 사용한 후에 꼭 닫아줘야 하는 것들이 있다. 그래야 사용했던 자원(resources)이 반환되기 때문이다.

### **예외 되던지기(exception re-throwing)**

한 메서드에서 발생할 수 있는 예외가 여럿인 경우, 몇 개는 try-catch문을 통해서 메서드 내에서 자체적으로 처리하고, 나머지는 선언부에 지정하여 호출한 메서드에서 처리하도록 함으로써 양쪽에서 나눠서 처리되도록 할 수 있다. 또한, 단 하나의 예외에 대해서도 예외가 발생한 메서드와 호출한 메서드, 양쪽에서 처리하도록 할 수 있다.

- 예외 되던지기(exception re-throwing) : 예외를 처리한 후에 인위적으로 다시 발생시키는 방법

먼저 예외가 발생할 가능성이 있는 메서드에서 try-catch문을 사용해서 예외를 처리해주고 catch문에서 필요한 작업을 행한 후에 throw문을 사용해서 예외를 다시 발생시킨다.

다시 발생한 예외는 이 메서드를 호출한 메서드에게 전달되고 호출한 메서드의 try-catch문에서 예외를 또다시 처리한다.

이 방법은 하나의 예외에 대해서 예외가 발생한 메서드와 이를 호출한 메서드 양쪽 모두에서 처리해줘야 할 작업이 있을 때 사용된다. 이때, 예외가 발생할 메서드에서는 try-catch문을 사용해서 예외처리를 해줌과 동시에 메서드의 선언부에 발생할 예외를 throws에 지정해줘야 한다.

### java.lang 패키지

Object 클래스는 모든 클래스의 최고 조상이기에 Object 클래스의 멤버들은 모든 클래스에서 바로 사용 가능하다. 

- equals(Object obj)

```java
public boolean equals(Object obj) {
	return (this == obj);
}
```

매개변수로 객체의 참조변수를 받아서 비교하여 그 결과를 boolean값으로 알려준다.

두 객체의 같고 다름을 참조변수의 값으로 판단한다. 

**따라서, 서로 다른 두 객체를 equals메서드로 비교하면 항상 false를 결과로 얻게 된다.**

- 객체를 생성할 때, 메모리의 비어있는 공간을 찾아 생성하므로 서로 다른 두 개의 객체가 같은 주소를 갖는 일은 있을 수 없다. 
두 개 이상의 참조변수가 같은 주소값을 갖는 것(한 객체를 참조하는 것)은 가능하다.
Object클래스로부터 상속받은 equals메서드는 결국 두 개의 참조변수가 같은 객체를 참조하고 있는지, 즉 두 참조변수에 저장된 값(주소값)이 같은지를 판단하는 기능만을 가지고 있다.

**인스턴스가 가지고 있는 값을 비교하기 위해서는 equals메서드를 오버라이딩하여 주소가 아닌 객체에 저장된 내용을 비교하도록 변경해주어야 한다.**

String클래스 역시 Object클래스의 equals메서드를 그대로 사용하는 것이 아니라, 오버라이딩을 통해 String인스턴스가 갖는 문자열 값을 비교하도록 되어있다. 그렇기 때문에 같은 내용의 문자열을 갖는 두 String인스턴스에 equals메서드를 사용하면 항상 true값을 얻는다.
String클래스뿐만 아니라, Date, File, wrapper클래스(Integer, Double 등)의 equals메서드도 주소값이 아닌 내용을 비교하도록 오버라이딩되어 있다. 그러나 StringBuffer클래스는 오버라이딩되어 있지 않다.

- hashCode( )

해싱(hasing)기법에 사용되는 해시함수(hash function)를 구현한 것이다.

(해싱은 데이터관리기법 중의 하나로, 다량의 데이터를 저장하고 검색하는 데 유용하다.)

해시함수는 찾고자 하는 값을 입력하면, 그 값이 저장된 위치를 알려주는 해시코드(hashcode)를 반환해준다. 일반적으로 해시코드가 같은 두 객체가 존재하는 것이 가능하지만, Object클래스에 정의된 hashCode메서드는 객체의 주소값을 이용해서 해시코드를 만들어 반환하기 때문에 서로 다른 두 객체는 같은 해시코드를 가질 수 없다.

클래스의 인스턴스변수 값으로 객체의 같고 다름을 판단해야하는 경우라면 equals메서드 뿐만 아니라 hashCode메서드도 적절히 오버라이딩해야한다.

같은 객체라면 hashCode메서드를 호출했을 때의 결과값인 해시코드도 같아야 하기 때문이다. 만일 hashCode메서드를 오버라이딩하지 않는다면 Object클래스에 정의된 대로 모든 객체가 서로 다른 해시코드값을 가질 것이다.
해싱기법을 사용하는 HashMap이나 HashSet과 같은 클래스에 저장할 객체라면 반드시 hashCode메서드를 오버라이딩해야 한다.

- toString( )

인스턴스에 대한 정보를 문자열(String)로 제공할 목적으로 정의한 것이다. 인스턴스의 정보를 제공한다는 것은 대부분의 경우 인스턴스 변수에 저장된 값들을 문자열로 표현한다는 의미이다. 

클래스를 작성할 때 toString()을 오버라이딩하지 않는다면, toString()을 호출할 경우 클래스이름에 16진수의 해시코드를 얻게 된다. 

getClass()와 hashCode() 역시 Object클래스에 정의된 것이므로 인스턴스 생성없이 바로 호출할 수 있다.

- clone( )

자신을 복제하여 새로운 인스턴스를 생성한다.

어떤 인스턴스에 대해 작업을 할 때, 원래의 인스턴스는 보존하고 clone메서드를 이용해서 새로운 인스턴스를 생성하여 작업을 하면 작업 이전의 값이 보존되므로 작업에 실패해서 원래의 상태로 되돌리거나 변경되기 전의 값을 참고하는데 도움이 된다.
