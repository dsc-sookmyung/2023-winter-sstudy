# Command
## 핵심 의도

요청 내역을 객체로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화하거나 메모리에 보관할 수 있다. 

## 적용 상황

요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수 있다. 재실행이나 우선순위에 따라 명령어를 실행하거나 배치 실행도 가능하다.

## 솔루션의 구조와 각 요소의 역할

![image](https://user-images.githubusercontent.com/53958188/218315167-3a29d6fe-353b-43f9-bc16-b46bd7d8579a.png)

### 객체에게 책임을 분할하기

요청을 보내는 책임과 그 요청을 처리하는 책임은 각각 Client와 Receiver에게 있다. 예를 들어 사용자가 선풍기를 켜고 싶다면 요청을 보내는 책임은 사용자에게, 선풍기를 켜는 요청을 처리하는 책임은 선풍기에게 있다. 그리고 사용자의 요청들을 중간에서 기록하고 전달하는 책임은 Invoker가 한다. 사용자가 선풍기 뿐만 아니라 부엌 불, 라디오 등을 키거나 끄고 싶다면 리모컨에 명령을 기록해두고 요청을 날릴 수 있는데 리모컨이 Invoker의 역할을 한다. 그리고 Invoker가 사용자의 요청을 Reciever에게 보내려면 통일된 인터페이스로 묶어주어야 하는데 이것이 Command 인터페이스이고, 이를 구현한 구체적인 커맨드 클래스는 Reciever에게 요청을 보내는 역할을 한다. 

### 구현 포인트

1. ConcreteCommand는 execute()에서 Receiver 객체에게 메시지를 요청해 동작 수행을 요청한다. 
2. ConcreteCommand가 undo() 동작을 수행할 때는 이전에 요청 내용과 상태를 저장해두었다가 반대 동작을 수행한다. 예를 들어 불을 켜는 동작에 대해 취소를 요청했다면 불을 끄는 동작을 실행하면 된다.
3. Invoker의 생성자로 커맨드 클래스를 초기화할 때 빈 클래스는 NoCommand 객체로 초기화한다. NoCommand는 null 객체인데, 딱히 리턴할 객체가 없고 클라이언트가 null을 처리하지 않게 하고 싶을 때 활용한다. 
4. Invoker의 Command 클래스를 초기화할 때, ConcreteCommand 클래스 생성자를 하나씩 생성해 넘겨주기보다 람다식을 사용하면 더 깔끔하게 코드를 작성할 수 있다. 하지만 Command 인터페이스에 메소드가 하나일 때만 가능하다.

## 적용 예시

### 요구사항

홈 오토메이션 장치 관리를 위한 리모컨을 개발한다. 리모컨에는 7개의 슬롯이 있고, 슬롯마다 on off 버튼이 있다. 각 버튼에 명령을 할당하면 그 버튼에 맞는 커맨드 객체의 execute() 메소드가 호출되고, 조명 선풍기 오디오 등에서 특정 행동을 담당하는 메소드가 실행된다.

### 설계

![image](https://user-images.githubusercontent.com/53958188/218315179-969ad598-5543-4697-ad27-7ddd55db59b6.png)

Client는 RemoteLoader(테스트 클래스)이, Invoker는 RemoteControl, Receiver는 Light 등의 클래스가 담당한다. ConcreteCommand는 LightOnCommand, LightOffCommand 등의 클래스가 구현하고 Receiver의 메소드를 호출한다.

# Adapter
## 핵심 의도

특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인스턴스로 변환한다. 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와준다.

## 적용 상황

클라이언트가 기존에 사용하고 있는 인터페이스가 있는데, 호환되지 않는 새로운 인터페이스를 기존 인터페이스(타깃)으로 사용하고 싶을 때 어댑터 패턴을 사용한다.

## 솔루션의 구조와 각 요소의 역할

![image](https://user-images.githubusercontent.com/53958188/218315247-86c0ec85-ba56-4d17-a5b7-08ca1683b82a.png)


위의 그림은 객체 어댑터의 구조. 다중 상속이 가능한 언어로 클래스 어댑터도 만들 수 있다. 타깃과 어댑티를 상속하여 어댑터를 만든다.

### 객체에게 책임을 분할하기

우선 클라이언트가 기존에 사용하고 있는 인터페이스가 Target이다. 그리고 새롭게 사용하려고 하는 인터페이스가 Adaptee이다. 클라이언트가 Adaptee를 Target 타입으로 사용하려면 이 둘 사이에 요청을 통과시켜줄 수 있는 책임이 필요한데, 이를 Adapter가 수행한다.

### 구현 포인트

어댑터 클래스는 타깃 인터페이스를 구현하고, 어댑티 클래스를 구성으로 가진다. 그래서 타깃 인터페이스로 메시지가 요청이 오면 어댑티의 메시지를 호출하여 메시지를 통과시킨다.

## 적용 예시

### 요구사항

기존에 사용하던 Iterator 인터페이스에 Enumeration 인터페이스를 추가로 사용하려고 한다. 클라이언트는 Iterator 타입으로 Enumeration을 사용한다.

### 설계

![image](https://user-images.githubusercontent.com/53958188/218315259-821c3508-6423-4fff-83b9-e3b1f13c588a.png)


어댑터인 EnumerationIterator는 타깃인 Iterator을 구현하고 어댑티인 Enumeration을 구성으로 가진다. Iterator의 추상 메소드를 구현할 때 Enumeration의 메소드를 호출하면 되는데, remove()는 대응하는 메소드가 없으므로 예외를 던진다. 클라이언트는 어댑터를 통해 Iterator로 Enumeration을 사용할 수 있다.


# Template

## 핵심 의도

알고리즘의 구조는 유지하면서 알고리즘의 특정 단계를 서브클래스에서 구현하거나 재정의하는 방법이다.

## 적용 상황

코드의 유사성이 높은데 코드의 일부분이 다른 경우, 템플릿 메소드로 공통인 부분은 상위로 올리고 다른 부분만 서브 클래스에서 구현하게 한다. 코드가 그대로 중복되는 것을 막을 수 있고, 공통 인터페이스를 사용해 메시지를 요청할 수 있다.

프레임워크를 제공할 때 자주 사용한다. 프레임워크는 사용자로 하여금 작업 흐름을 강제하는데, 템플릿 메소드에서 알고리즘 구조를 제어할 수 있다. 그러면서도 알고리즘의 각 단계는 사용자가 마음대로 지정할 수 있다.

## 솔루션의 구조와 각 요소의 역할

![image](https://user-images.githubusercontent.com/53958188/218315286-0a14eda2-5cb6-4249-94f6-9e50b29f497a.png)


### 객체에게 책임을 분할하기

일련의 알고리즘을 정의한 메소드인 템플릿 메소드를 가진 상위 클래스가 필요하다. 템플릿 메소드에서 호출하는 알고리즘의 각 단계를 구현하는 서브 클래스도 필요하다.

### 구현 포인트

<aside>
💡 **템플릿 메소드에서 호출하는 메소드**

</aside>

1. 모든 서브 클래스에서 공통으로 사용하는 메소드
2. 각 서브 클래스에서 구현할 추상 메소드
3. 서브 클래스에서 오버라이딩할 수 있는 **후크 메소드**

공통 메소드는 상위 클래스에서 구현해야하며, 외부의 메시지에 응답할 때 이 공통 메소드는 상위 클래스에서 처리한다. 반면 추상 메소드는 서브 클래스에 의존하므로 이 동작은 서브 클래스에서 처리한다. 

후크는 다양한 용도로 사용할 수 있는데, **알고리즘의 특정 단계가 선택적으로 적용되는 경우 후크를 상위 클래스에 둔다.** 알고리즘에서 필수적이지 않은 부분을 서브클래스에서 구현하도록 만들고 싶을 때, 서브클래스가 알고리즘의 각 단계를 처리할지 말지 결정하게 하고 싶을 때, 템플릿 메소드에서 일어나는 일에 대해 서브 클래스가 반응할 수 있도록 하고 싶을 때 사용한다.

<aside>
💡 **할리우드 원칙 - 먼저 연락하지 마세요. 저희가 연락 드리겠습니다**

</aside>

이 원칙을 사용하면 저수준 구성 요소가 고수준 구성 요소에 접속할 수ㅇ는 있지만, 그 구성 요소를 어떻게 사용할지는 고수준 구성 요소가 결정한다. 이렇게 하면 수준별로 의존성이 꼬이는 문제를 막을 수 있다. 

템플릿 메소드 패턴을 사용하면 할리우드 원칙을 지키게 된다. 알고리즘을 실행할 때 서브 클래스에 의존하고 있는 메소드를 호출하게 되면 그때 상위 클래스가 서브 클래스에게 메시지를 전송하기 때문이다.

<aside>
💡 템플릿 메소드 패턴 vs 전략 패턴 vs 팩토리 메소드 패턴

</aside>

- 템플릿 메소드 : 알고리즘의 어떤 단계를 구현하는 방법을 서브클래스에서 결정한다. 상속을 사용한다.
- 전략 패턴 : 바꿔 쓸 수 있는 행동을 캡슐화하고, 어떤 행동을 사용할지는 서브클래스에게 맡긴다. 구성을 사용한다.
- 팩토리 메소드 : 생성이라는 알고리즘에 집중한 템플릿 메소드 패턴이다.

## 적용 예시

### 요구사항

커피와 홍차를 제조한다. 커피는 물을 끓이고, 커피를 우려내고, 커피를 컵에 따르고, 설탕과 우유를 추가한다. 홍차는 물을 끓이고, 찻잎을 우려내고, 홍차를 컵에 따르고, 레몬을 추가한다. 두 종류의 음료를 제조하는 코드의 중복을 제거해보자.

### 설계



prepareRecipe()는 템플릿 메소드이다. 이 템플릿 메소드는 CaffeinBeverage를 상속하는 모든 서브 클래스 음료의 제조 알고리즘을 제어한다. 나머지 네개의 메소드는 템플릿 메소드에서 호출되는 각 단계의 알고리즘이며, brew()와 addCondiments()는 서브 클래스에서 각자 구현한다.

# Iterator

## 핵심 의도

컬렉션의 구현 방법을 노출하지 않으면서 집합체 내의 모든 항목에 접근하는 방법을 제공한다. 집합체를 사용하는 클라이언트는 집합체의 저장 방식을 몰라도 반복 작업을 할 수 있고, 집합체 역시 구체적인 저장방식을 공개하지 않아도 되므로 더 유연하고 다형적인 코드를 작성할 수 있다.

## 적용 상황

서로 다른 타입의 컬렉션에 대해 동일한 인터페이스로 모든 항목에 접근하고 싶을 때 사용한다. 예를 들어 배열이나 ArrayList를 가진 객체를 인터페이스로 한번 감싸서 동일한 인터페이스로 모든 항목에 접근할 수 있다. 

자바에서 제공하는 Iterator 인터페이스를 사용하면 편리하다. 클라이언트 사용 객체가 자신이 가진 컬렉션에 해당하는 Iterator 구현체를 반환하는 메소드를 두면 된다. 배열은 Iterator 구현체가 따로 없으므로 만들어서 반환한다.

자바의 모든 컬렉션 유형은 Iterable 인터페이스를 구현한다. Iterable은 Iterator 인터페이스를 구현하는, 반복자를 리턴하는 iterator() 메소드가 들어있다. 

## 솔루션의 구조와 각 요소의 역할

![image](https://user-images.githubusercontent.com/53958188/218315409-0b7cf0a9-b082-497c-94b4-90d8d217f8e5.png)


### 객체에게 책임을 분할하기

클라이언트가 사용하려고 하는 컬렉션과 그 부가기능을 제공하는 책임은 ConcreteAggregate에게 있으며, 여러 종류의 객체가 존재할 수 있으므로 Aggregate 인터페이스로 접근한다. ConcreteAggregate가 가진 컬렉션의 모든 항목을 접근할 수 있게 하는 기능은 ConcreteIterator에게 있다. ConcreteAggregate가 다른 컬렉션을 가지고 있을 수 있으므로 Iterator도 인터페이스로 접근한다.

### 구현 포인트

자바에서 제공하는 Iterator 인터페이스는 hasNext(), next(), remove()를 구현하도록 하고 있다. 만약 remove() 구현이 필요하지 않다면 예외를 던져 처리한다.

반복자 패턴을 사용하면 집합체에서 내부 컬렉션 관리 기능과 반복자용 메소드 기능을 분리할 수 있다. 클래스의 변경 이유를 분리한 것이므로 SRP(단일 책임 원칙)를 지키고 있다.

## 적용 예시

### 요구사항

배열로 메뉴를 관리하는 Diner 식당과 리스트를 사용하는 PancakeHouse가 합병한다. 종업원은 동일한 인터페이스로 두 식당의 메뉴 목록을 설명할 수 있어야 한다.

### 설계

![image](https://user-images.githubusercontent.com/53958188/218315395-66968a9f-d8ec-416a-a5e0-0ea5a1040136.png)


종업원은 Menu라는 인터페이스로 두 식당의 메뉴 객체에 접근할 수 있다. Menu 구현체들은 반복자 관련 구현체인 Iterator 객체를 반환한다. 각각 배열과 리스트에 맞는 Iterator을 반환하는데, 배열은 java util에서 제공하는 반복자가 없으므로 따로 생성해 반환한다.
