# Composite

## 핵심 의도

클라이언트에서 개별 객체와 복합 객체를 똑같은 방법으로 다룰 수 있다. 개별 객체와 복합 객체는 서로 포함 관계인데, 객체를 트리구조로 구성해서 부분-전체 계층 구조를 구현한다.

## 적용 상황

계층 구조가 있는 자료구조의 아이템에 대해 공통된 인터페이스로 접근할 때 사용한다. 컴포지트 패턴을 사용하면 클라이언트에게는 계층 구조가 보이지 않기 때문에 클라이언트의 사용 코드가 매우 단순해진다는 장점이 있다.

## 솔루션의 구조와 각 요소의 역할

### 객체에게 책임을 분할하기

개별 객체(leaf)와 복합 객체(composite)가 존재하는 상황. 클라이언트는 개별 객체와 복합 객체를 동일한 방법으로 사용하고자 하므로 개별 객체와 복합 객체를 공통으로 묶는 인터페이스인 Component를 둔다. Component는 객체가 원래 가진 책임과 함께 계층구조를 관리하는 책임을 가진다. 

### 구현 포인트

> Composite와 반복자
> 

Composite는 복합 객체이다. 복합 객체는 자식으로 개별 객체를 두거나 또다른 복합 객체를 둘 수 있다. 따라서 Composite는 개별객체와 복합객체를 둘다 가질 수 있는 컬렉션을 가진다. Component 타입의 컬렉션을 구성으로 두면 된다. 복합 객체가 자신의 모든 자식들에 접근하려고 할 때, 컬렉션이 제공하는 Iterator이 있다면 향상된 for 순환문을 사용할 수 있다.

> Component 메소드 구현
> 

모든 구성 요소는 Component 인터페이스를 구현한다. 하지만 잎과 노드는 각각 역할이 다르므로, 모든 메소드에 알맞는 기본 메소드 구현은 불가능하다. 그래서 자기 역할에 맞지 않는 상황을 기준으로 예외를 던지는 코드를 기본 구현으로 제공할 수 있다.

> SRP 위반
> 

Component는 객체가 원래 가진 책임과 함께 계층구조를 관리하는 책임을 가진다. 이는 단일 책임 원칙을 위반한다. 하지만 기능을 전부 넣어서 클라이언트가 복합 객체와 단일 객체를 똑같은 방식으로 처리할 수 있도록 만들 수 있다. 클라이언트는 어떤 원소가 복합 객체고 단일 객체인지 투명하게 볼 수 있다. 그럼에도 동일한 인터페이스를 사용해 접근할 수 있다.

만약 책임을 분리하여 계층구조 관리 책임을 다른 인터페이스로 분리한다면, 클라이언트는 조건문이나 Instanceof 연산자 등을 사용해서 단일 객체와 복합 객체를 구분하여 접근해야 한다. 하지만 책임을 확실하게 분리했으므로 부적절한 메소드 호출을 하지 않을 것이고 실행 중에 문제가 발생하지 않을 것이다.

상황에 따라 원칙을 적절하게 사용해야 한다. SRP를 위반하여 내부 구조를 공개하더라도, 클라이언트가 동일한 인터페이스로 간단하게 접근할 필요성이 더 크다면 컴포지트 패턴처럼 투명성을 확보하게 할 수 있다.

## 적용 예시

### 요구사항

Diner 식당의 메뉴에는 여러 단일 식사 메뉴들이 있다. 여기에 디저트 메뉴 집단을 Diner 식당 메뉴의 서브 메뉴로 추가하려고 한다. 클라이언트는 여전히 식당의 서브 메뉴와 단일 메뉴들을 동일한 인터페이스로 접근한다.

### 설계

식당의 서브 메뉴와 단일 메뉴는 계층 구조를 가진다. 단일 메뉴는 MenuItem가, 서브 메뉴는 Menu가 구현한다. 그리고 클라이언트가 이 계층 구조에 접근할 수 있도록 All Menus라고 하는 최상위 객체를 둔다. 그리고 서브 메뉴와 단일 메뉴에 접근할 때는 재귀적으로 접근한다. 서브 메뉴는 자식으로 단일 메뉴 혹은 서브 메뉴를 가지기 때문이다.


# State
## 핵심 의도

상태 패턴을 사용하면 내부 상태가 바뀜에 따라 객체의 행동을 바꿀 수 있다. 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있다.

## 적용 상황

상태 다이어그램을 구현할 때 사용할 수 있다. 특히 상태에 따라 행동이 바뀌는 경우에 적합하다. 상태를 캡슐화하지 않고 그대로 조건문으로 행동을 처리하면 수많은 조건문으로 인해 가독성이 떨어지고 관리가 어려워진다. 상태 패턴은 상태와 함께 관련된 행동을 캡슐화하므로, 상태 변경을 통해 행동을 변경할 수 있다.

## 솔루션의 구조와 각 요소의 역할

### 객체에게 책임을 분할하기

상태 다이어그램을 생각해보면, 각각의 상태를 나타내는 책임과 상태를 가지고 관리하고 변경하는 책임이 필요하다. 상태는 여러개 존재하므로 State라는 공통 인터페이스를 따르게 하고, 상태를 가지고 변경하는 책임은 Context가 가진다. 클라이언트는 Context에게 특정 행동을 하도록 메시지를 보내고, Context는 내부적으로 상태를 변경하여 자신이 할 수 있는 행동을 바꾼다.

### 구현 포인트

> State는 인터페이스일까 추상클래스일까?
> 

둘다 가능하다. State는 상태 클래스에서 사용하는 모든 행동의 명세를 가지고 있어야 한다. (그래서 어떤 구상 클래스에서는 허용되지 않는 행동에 대해 적절한 처리를 해야한다) 만약 모든 구상 클래스에서 같은 행동을 하도록 만들고 싶다면 추상클래스에 구상 메소드를 둘 수 있다. 모든 행동을 구상 클래스에서 구현하도록 하고 싶다면 인터페이스로 두어야 한다. 

> 전략 패턴과 상태 패턴
> 

상태 패턴과 전략 패턴의 클래스 다이어그램은 동일하다. 둘다 구성과 위임으로 객체가 다른 행동과 알고리즘을 보일 수 있도록 한다. 하는 일은 유사하지만, 그 목적은 다르다. 전략 패턴은 클라이언트가 Context 객체에게 어떤 전략 객체를 사용할지 지정한다. 하지만 상태 패턴에서 클라이언트는 상태 객체를 모른다. 어떤 상태 객체가 사용될지 결정하는 것은 클라이언트와 상관 없이 Context 객체가 결정한다. 

## 적용 예시

### 요구사항

다음과 같은 상태 기계를 가지는 뽑기 기계를 구현한다.

### 설계

State 인터페이스에는 뽑기 기계가 각 상태에서 보일 수 있는 모든 행동의 명세를 가지고 있다. 그리고 구상 상태 클래스에서 행동을 구현한다. 이때 상태마다 구현할 필요가 없는 행동은 그냥 실행할 수 없다는 메시지를 출력한다.


# Proxy

## 핵심 의도

특정 객체로의 접근을 제어하는 대리인을 제공한다. 클라이언트가 실제 객체의 메소드를 호출하면 그 호출을 중간에 가로챈다. 

## 적용 상황

사용되는 상황이 많은데, 공통점은 클라이언트가 진짜 객체에 직접 메시지 요청을 보내지 않도록 한다는 점이다. 진짜 객체에 바로 메시지가 가기 전에 접근을 제어해야 할 때 사용한다.

1. 원격 프록시
    
    원격 객체로의 접근을 제어한다. 서로 다른 JVM에 존재하는 객체는 직접 데이터를 주고받을 수 없으므로 프록시 객체를 통해 접근을 제어한다. 원격 프록시는 접근을 제어해 네트워크 관련 사항을 처리한다.
    
2. 가상 프록시
    
    생성하는데 많은 비용이 드는 객체를 대신한다. 진짜 객체가 필요한 상황이 오기 전까지 객체의 생성을 미루거나 객체를 대신한다. 객체 생성이 끝나면 진짜 객체에 직접 요청을 전달한다.
    
3. 보호 프록시
    
    접근 권한이 필요한 자원으로의 접근을 제어한다. 접근 권한마다 프록시를 두어 클라이언트가 진짜 객체에 접근하기 전에 접근 권한을 검사한다. 메시지는 요청을 보낸 클라이언트, 메소드, 인자 등으로 구분할 수 있다.
    
4. 방화벽 프록시
    
    일련의 네트워크 자원으로의 접근을 제어하여 진짜 객체를 나쁜 클라이언트로부터 보호한다.
    
5. 스마트 레퍼런스 프록시
    
    진짜 객체가 참조될 때마다 추가 행동을 제공한다. 객체의 레퍼런스 개수를 센다든가..
    
6. 캐싱 프록시
    
    비용이 많이 드는 작업의 결과를 임시로 저장해 준다. 여러 클라이언트에서 결과를 공유하게 해줌으로써 계산 시간과 네트워크 지연을 줄여준다.
    
7. 동기화 프록시
    
    여러 스레드에서 주제에 접근할 때 안전하게 작업을 처리할 수 있다.
    
8. 복잡도 숨김 프록시
    
    복잡한 클래스의 집합으로의 접근을 제어하고 그 복잡도를 숨겨준다. 퍼사드 프록시라고 부르기도 한다. 이 프록시와 퍼사드 패턴의 차이점은 프록시는 접근을 제어하지만 퍼사드 패턴은 대체 인터페이스만 제공한다.
    
9. 지연 복사 프록시
    
    클라이언트에서 필요로 할 때까지 객체가 복사되는 것을 지연시킴으로써 객체의 복사를 제어한다. 변형된 가상 프록시로 볼 수 있다.
    

정말 많은 프록시 패턴의 종류가 있는데, 결국 **공통점은 클라이언트가 실제 객체의 메소드를 호출할 때 그 호출을 중간에 가로채어 부가 작업을 하는 것에 있다.**

## 솔루션의 구조와 각 요소의 역할


### 객체에게 책임을 분할하기

진짜 객체인 RealSubject와 클라이언트가 존재한다. 클라이언트는 진짜 객체에 접근하려고 한다. 접근 제어를 하는 책임을 담당하는 객체는 Proxy이다. 클라이언트는 Proxy를 통해 RealSubject에 메시지를 보내므로 동일한 인터페이스를 사용해야 한다.

### 구현 포인트

> RMI
> 

분산 객체 간의 통신을 구현하는 모든 프로토콜을 의미한다. 분산되어 존재하는 객체 간의 메시지 전송을 가능하게 하는 프로토콜이다. Java가 제공하는 RMI를 사용하면 통상 네트워크 프로그래밍할 때 사용하는 소켓 통신을 하부에 숨기고 상위 레벨에서 수행할 수 있다. 분산 객체 간의 데이터 전송을 애플리케이션 함수 호출 형태로 구현할 수 있기 때문에 훨씬 쉽다. RMI를 사용하면 서로 다른 JVM의 힙에 존재하는 객체 간에 메시지를 전송할 수 있다. 자바가 제공하는 라이브러리기 때문에 통신에 대한 신뢰성을 확보할 수 있다. 자바의 RMI에 원격 프록시 패턴이 적용되어 있다.


**자바 RMI에 적용된 프록시 패턴 찾기**

클라이언트 객체는 원격에 있는 서비스 객체에 메소드 호출을 통해 메시지를 보낸다. 네트워크 통신을 처리해야하므로 클라이언트와 서버 측에서 네트워크 통신을 처리하는 객체가 필요하다. 클라이언트 측은 스텁, 서버 측은 스켈레톤이라고 부른다. 

클라이언트는 서비스 객체에게 요청을 보내고 응답을 받는다고 생각하지만, 실제로 클라이언트는 보조 객체인 스텁에게 요청을 보낸다. 그러면 스텁이 그 요청을 원격 객체에게 전달한다. 스텁은 서버에 연락을 취하고, 메소드 호출에 관한 정보를 전달하고, 서버로부터 리턴되는 정보를 기다리고 클라이언트 객체에게 전달한다.

서비스 보조 객체인 스켈레톤은 클라이언트 보조 객체로부터 요청을 받아 오고, 호출 정보를 해석해 진짜 서비스 객체에 있는 진짜 메소드를 호출한다. 그러면 서비스 객체는 그 메소드 호출이 원격 클라이언트가 아닌 로컬 객체로부터 들어온다고 생각한다. 스켈레톤은 서비스로부터 리턴값을 받아서 Socket의 출력 스트림으로 클라이언트 보조 객체에게 전송한다.

스텁과 스켈레톤은 클라이언트 객체와 서비스 객체 앞에서 접근을 제어하는 프록시 객체이다. 스텁은 클라이언트 객체로 들어오는 응답을 직렬화하여 전달하고, 클라이언트 객체에서 나가는 요청은 통신 처리하여 보낸다. 스켈레톤은 서비스 객체로 들어오는 외부 요청을 받아들여 로컬에서 보낸 요청처럼 처리한다. 

**RMI 구현**

1. 원격 인터페이스를 만든다.
2. 실제 서비스 객체에 인터페이스를 구현하고 서비스를 RMI 레지스트리에 등록한다. RMI 시스템이 레지스트리에 스텁만 등록해준다.
3. RMI 레지스트리를 실행한다.
4. 원격 서비스를 실행한다.

**RMI 작동 방식**

1. 클라이언트에서 RMI 레지스트리를 룩업한다.
2. RMI 레지스트리에서 스텁 객체를 리턴한다.
3. 클라이언트는 스텁의 메소드를 호출한다. 스텁이 진짜 서비스 객체라고 생각한다.

> 동적 프록시
> 

자바의 java.lang.reflect 패키지 안에 프록시 기능이 내장되어 있다. 이 패키지를 사용하면 즉석에서 하나 이상의 인터페이스를 구현하고, 지정한 클래스에 메소드 호출을 전달하는 클래스를 만들 수 있다. 진짜 프록시 클래스는 실행 중에 생성된다.

자바에서 Proxy 클래스를 생성해주므로, Proxy 클래스에게 무슨 일을 해야 하는지 알려주는 책임을 InvocationHandler가 가진다. InvocationHandler는 프록시에 호출되는 모든 메소드에 응답한다. 

다음과 같이 InvocationHandler에 접근 제어를 구현한다.

```java
import java.lang.reflect.*;
 
public class OwnerInvocationHandler implements InvocationHandler { 
	Person person;
 
	public OwnerInvocationHandler(Person person) {
		this.person = person;
	}
 
	public Object invoke(Object proxy, Method method, Object[] args) 
			throws IllegalAccessException {
  
		try {
			if (method.getName().startsWith("get")) {
				return method.invoke(person, args);
   			} else if (method.getName().equals("setGeekRating")) {
				throw new IllegalAccessException();
			} else if (method.getName().startsWith("set")) {
				return method.invoke(person, args);
			} 
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        } 
		return null;
	}
}
```

그리고 동적 프록시를 생성하는 코드를 작성한다.

```java
Person getOwnerProxy(Person person) {
	return (Person) Proxy.newProxyInstance( 
		person.getClass().getClassLoader(),
		person.getClass().getInterfaces(),
		new OwnerInvocationHandler(person));
}
```

이렇게 사용한다.

```java
public static void main(String[] args) {
		MatchMakingTestDrive test = new MatchMakingTestDrive();
		test.drive();
	}
 
	public MatchMakingTestDrive() {
		initializeDatabase();
	}

	public void drive() {
		Person joe = getPersonFromDatabase("Joe Javabean"); 
		Person ownerProxy = getOwnerProxy(joe);
		System.out.println("Name is " + ownerProxy.getName());
		ownerProxy.setInterests("bowling, Go");
		System.out.println("Interests set from owner proxy");
		try {
			ownerProxy.setGeekRating(10);
		} catch (Exception e) {
			System.out.println("Can't set rating from owner proxy");
		}
		System.out.println("Rating is " + ownerProxy.getGeekRating());

		Person nonOwnerProxy = getNonOwnerProxy(joe);
		System.out.println("Name is " + nonOwnerProxy.getName());
		try {
			nonOwnerProxy.setInterests("bowling, Go");
		} catch (Exception e) {
			System.out.println("Can't set interests from non owner proxy");
		}
		nonOwnerProxy.setGeekRating(3);
		System.out.println("Rating set from non owner proxy");
		System.out.println("Rating is " + nonOwnerProxy.getGeekRating());
	}
```

# MVC
## 핵심 의도

모델-뷰-컨트롤러는 사용자에게 화면을 통해 입력을 받아 애플리케이션의 기능을 실행하는 프로그램에 적용할 수 있는 패턴이다. MVC는 옵저버, 전략, 컴포지트 패턴으로 이루어진 복합 패턴이다. 복합 패턴을 통해 서로 느슨하게 결합되므로 깔끔하면서 유연하고 재사용 가능한 구현이 가능하다. 

## 적용 상황

클라이언트에게 화면을 보여주고 뒷단에서 처리하는 대부분의 프로그램에 적용 가능하다. 웹, 특히 클라이언트-서버 애플리케이션 구조에 MVC를 적응시켜주는 다양한 웹 MVC 프레임워크가 있다.

## 솔루션의 구조와 각 요소의 역할

### 객체에게 책임을 분할하기

사용자에게 화면을 보여주고 명령을 받아 실행하는 애플리케이션의 책임을 나열해보자. 우선 사용자에게 화면을 만들어 보여주는 책임(뷰), 애플리케이션 기능을 구현하는 책임(모델), 사용자에게 입력을 받아 애플리케이션 기능을 호출하는 책임(컨트롤러)으로 나눌 수 있다. 사실 화면에서 입력을 받아 바로 애플리케이션 기능을 호출해도 되지만, 뷰나 애플리케이션 기능을 재사용하기 위해 컨트롤러를 도입해 결합도를 낮추었다. 

모델, 뷰, 컨트롤러는 다음과 같이 상호작용한다.

1. 사용자는 뷰와 상호작용한다. 사용자가 뷰에서 버튼을 누른다든가 동작을 하면 뷰는 무슨 일이 일어났는지 컨트롤러에게 알려준다. 그러면 컨트롤러가 상황에 맞게 작업을 처리한다.
2. 컨트롤러가 모델에게 상태를 변경하라고 요청한다. 컨트롤러는 사용자의 행동을 받아서 해석한다. 사용자가 버튼을 클릭하면 컨트롤러는 그것이 무엇을 의미하는지 해석하고, 모델을 어떤 식으로 조작해야하는지 결정한다.
3. 컨트롤러가 뷰를 변경해달라고 요청할 수도 있다. 예를 들어 컨트롤러는 인터페이스에 있는 어떤 버튼이나 메뉴를 활성화하거나 비활성화도록 요청할 수 있다.
4. 상태가 변경되면 모델이 뷰에게 그 사실을 알린다. 사용자가 한 행동이나 다른 내부적인 변화 등으로 모델에서 무언가가 바뀌면 모델은 뷰에서 상태가 변경되었다고 알린다.
5. 뷰가 모델에게 상태를 요청한다. 뷰는 화면에 표시할 상태를 모델로부터 직접 가져온다. 모델로부터 상태 변화가 생겼다는 연락을 받거나, 컨트롤러가 뷰에게 무언가를 바꾸라고 요청했을 때 뷰는 모델에게 상태를 알려달라고 요청한다.

### 구현 포인트

> 모델 - 옵저버 패턴
> 

모델은 상태가 변경될 때마다 모델과 연관된 객체들에게 연락한다. 옵저버 패턴을 사용하면 모델을 뷰와 컨트롤러로부터 완전히 독립시킬 수 있다. 한 모델에서 서로 다른 뷰를 사용할 수도 있고, 

> 뷰 - 컴포지트 패턴
> 

디스플레이는 여러 단계로 겹쳐 있는 윈도우, 패널, 버튼, 텍스트 레이블 등으로 구성된다. 각 디스플레이 항목은 복합 객체(윈도우)나 잎(버튼)이 될 수 있다. 컨트롤러가 뷰에게 화면을 갱신해달라고 요청하면 최상위 뷰 구성 요소에게만 화면을 갱신하라고 얘기하면 된다. 나머지는 컴포지트 패턴이 알아서 처리해준다.

> 컨트롤러 - 전략 패턴
> 

뷰와 컨트롤러는 고전적인 전략 패턴으로 구현되어 있다. 컨트롤러는 여러 전략을 제공하고, 뷰는 이 전략을 써서 화면을 구성한다. 뷰는 애플리케이션의 겉모습에만 신경 쓰고, 인터페이스의 행동을 결정하는 일은 모두 컨트롤러에게 맡긴다. 전략 패턴을 사용하면 뷰를 모델로부터 분리하는데 도움이 된다. 사용자의 요청 처리를 위해 모델과 상호작용하는 부분은 컨트롤러만 알고 뷰는 모르기 때문이다.


# 마치며
# 디자인 패턴을 쓰는 자세

디자인 패턴의 과다한 사용으로 불필요하게 복잡한 코드가 만들어질 수 있다. 항상 가장 간단한 해결책으로 목적을 달성할 수 있도록 하고, 반드시 필요할 때만 디자인 패턴을 적용하자. 디자인 패턴을 쓰는 것 못지 않게 훌륭한 객체지향 디자이너가 되는 것이 중요하다.

# 디자인 패턴의 범주

1. 생성 패턴

객체 인스턴스를 생성하는 패턴. 클라이언트와 그 클라이언트가 생성해야 하는 객체 인스턴스 사이의 연결을 끊어주는 패턴이다. 싱글턴, 추상 팩토리, 팩토리 메소드, 프로토 타입, 빌더가 있다.

1. 행동 패턴

클래스와 객체들이 상호작용하는 방법과 역할을 분담하는 방법을 다루는 패턴이다. 템플릿 메소드, 싱글턴, 반복자, 옵저버, 상태, 전략, 인터프리터, 역할 변경, 비지터, 중재자, 메멘토가 있다.

1. 구조 패턴

클래스와 객체를 더 큰 구조로 만들 수 있게 구성을 사용한다. 데코레이터, 컴포지트, 프록시, 퍼사드, 어댑터, 플라이웨이트, 브리지 등이 있다.

# 아직 배우지 않은 디자인 패턴들

- 브리지
- 빌더
- 책임 연쇄
- 플라이웨이트
- 인터프리터
- 중재자
- 메멘토
- 프로토타입
- 비지터

# 디자인 패턴 카탈로그 양식

- Name, Type
- Intent : 패턴의 역할, 정의
- Motivation : 문제를 기술하고 주어진 해결책이 어떤 식으로 문제를 해결하는지 보여주는 구체적인 시나리오
- Applicability : 그 패턴을 적용할 수 있는 상황
- Structure : 패턴에서 쓰이는 클래스의 다이어그램
- Participants : 클래스와 객체 설명. 패턴 내에서 각 클래스나 객체가 맡는 임무와 역할
- Collaborations : 구성 요소가 패턴 내에서 어떤 식으로 서로 도움을 주는지 설명
- Consequences : 이 패턴을 사용했을 때의 장단점
- Implementation/Sample Code
- Known Uses : 실제 시스템에서 이 패턴을 사용하는 예시 설명
- Related Patterns : 다른 패턴의 관계 설명
