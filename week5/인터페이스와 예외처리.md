### 추상클래스(abstract class)

추상클래스는 미완성인 메서드(추상 메서드)를 포함하고 있다. 추상 클래스로는 인스턴스를 생성할 수 없고, 상속을 통해서 자손클래스에 의해서만 완성될 수 있다. 

추상클래스는 그 자체로는 클래스로서의 역할을 하지 못하지만, 새로운 클래스를 작성하는데 있어서 바탕이 되는 조상클래스의 역할을 한다. 

키워드 abstract을 붙여주어 클래스를 사용할 때 클래스 선언부의 abstract을 보고 상속을 통해 구현해줘야한다는 것을 알 수 있다. 

```java
abstract class 클래스이름 {
				..
}
```

추상메소드

선언부만 작성해두고 구현부는 작성해주지 않은 채 남겨둔 것이 추상메소드이다. 

⇒ 메서드의 내용이 상속받는 클래스에 따라 달라지기 때문에, 조상 클래스에서는 선언부만 작성해두고 주석으로 어떤 기능을 수행할 목적인지 작성해 실제 내용은 상속받는 클래스에서 구현하도록 한다.

```java
abstract 리턴타입 메서드이름();
```

추상클래스로부터 상속받은 자손클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메서드를 모두 구현해줘야 한다. (조상클래스로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스도 추상클래스로 지정해줘야 한다)

- 추상화 : 클래스 간의 공통점을 찾아내서 공통의 조상을 만드는 작업
- 구체화 : 상속을 통해 클래스를 구현, 확장하는 작업

### 인터페이스

인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 일반 메서드나 멤버변수를 구성원으로 가질 수 없다.

```java
interfce 인터페이스이름 {
		public static final 타입 상수이름 = 값;
		public abstract 메서드이름(메서드변수);
}
```

인터페이스는 인터페이스로부터만 상속받을 수 있으며, 여러 개의 인터페이스로부터 상속받는 것이 가능하다. 인터페이스 그 자체로는 인스턴스를 생성할 수 없으며, 키워드 implements를 사용하여 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성한다.

- 클래스를 사용하는 쪽과 클래스를 제공하는 쪽이 있다.
- 메서드를 사용하는 쪽에서는 사용하려는 메서드의 선언부만 알면 된다.( 내용은 몰라도 된다.)
- 인터페이스와 다중상속
    
    자바에서는 다중 상속을 허용하지 않는다. 따라서 두 개의 클래스로부터 상속을 받아야하는 경우, 한쪽을 상속받고 나머지 한 쪽은 클래스 내에 포함시키거나 인터페이스를 사용해서 구현해준다. 
    
- 인터페이스의 장점
    - 개발 시간을 단축시킬 수 있다.
    - 표준화가 가능하다.
    - 서로 관계없는 클래스들에게 관계를 맺어줄 수 있다.
    - 독립적인 프로그래밍이 가능하다. → 클래스의 선언과 구현을 분리시켜 실제구현에 독립적인 프로그램을 작성할 수 있다.
- 디폴트 메서드와 static 메서드
    
    JDK1.8부터 인터페이스에 디폴트 메서드와 static 메서드도 추가할 수 있게 되었다.
    
    - 디폴트 메서드
        
        디폴트 메서드는 추상 메서드의 기본적인 구현을 제공하는 메서드로, 추상 메서드가 아니기에 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다. 아래처럼 키워드 default를 붙이며, 추상 메서드와 달리 일반 메서드처럼 몸통{ }이 있어야 한다. (접근 제어자는 public이며 생략 가능하다)
        
        ```java
        interface MyInterface {
        		void method();  // 추상 메서드
        		default void newMethod() {}  // 디폴트 메서드
        }
        ```
        
        디폴트 메서드를 추가하면, 기존의 MyInterface를 구현한 클래스를 변경하지 않아도 된다. (조상 클래스에 새로운 메서드를 추가한 것과 동일해진다.)
        

### 내부 클래스(inner class)

클래스 내에 선언된다는 점을 제외하고는 일반적인 클래스와 크게 다르지 않다. 두 클래스가 긴밀한 관계가 있을 때 사용한다.

- 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
- 코드의 복잡성을 줄일 수 있다. (캡슐화)
- 내부 클래스의 종류와 특징
    1. 인스턴스 클래스 : 외부 클래스의 멤버변수 선언위치에 선언, 주로 외부 클래스의 인서턴스 멤버들과 관련된 작업에 사용될 목적으로 선언된다.
    2. static 클래스 : 외부 클래스의 멤버변수 선언위치에 선언, 외부 클래스의 static 멤버처럼 쓰인다.
    3. 지역 클래스 : 외부 클래스의 메서드나 초기화 블럭 안에 선언하며, 선언된 영역 내부에서만 사용할 수 있다.
    4. 익명 클래스 : 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스이다. (일회용)
- 익명클래스
    
    다른 내부 클래스들과 달리 이름이 없고, 클래스의 선언과 객체의 생성을 동시에 하기에 단 한번만 사용되는 일회용 클래스이다. 이름이 없어 생성자를 갖지 못하며, 조상클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용해서 정의한다.
    
    ```java
    new 조상클래스이름() {
    		// 멤버 선언
    }
    
    new 구현인터페이스이름() {
    		// 멤버 선언
    }
    ```
    

### 예외처리

- 컴파일 에러 : 컴파일시 발생하는 에러
- 런타임 에러 : 프로그램 실행도중 발생하는 에러
- 논리적 에러 : 실행은 되지만, 의도와 다르게 동작하는 것

소스코드를 컴파일하면 컴파일러가 .java의 소스코드에 대해 기본적인 검사를 진행하고, 오류가 있는지 알려준다. 컴파일러가 알려준 오류를 모두 수정하여 컴파일을 성공적으로 마치고 나면, .class 클래스 파일이 생성되고 생성된 클래스 파일을 실행할 수 있다. 컴파일러가 기본적인 검사를 진행해주지만, 실행도중 발생하는 잠재적인 오류까지 검사할 수 없기에 런타임 에러를 만날 수도 있다. 런타임 에러를 방지하기 위해 자바에서는 프로그램 오류를 에러(error)와 예외(exception) 두가지로 구분한다. 

- Exception
    - IOException
    - ClassNotFoundException
    - ..
    - RunTimeException
        - IndexOutOfBoundsException
        - NullPointerException
        - ..

모든 예외의 최고 조상은 Exception이다.

예외 클래스는 기본적으로 두 그룹으로 나뉜다.

1. Exception 클래스와 그 자손들
2. RunTimeException 클래스와 그 자손들
- try-catch문
    
    예외처리는 프로그램 실행 시 발생할 수 있는 예외의 발생에 대비한 코드를 작성하는 것으로, 프로그램의 갑작스런 종료를 막고, 정상적인 실행상태를 유지할 수 있도록 하는 것이다. 
    
    ```java
    try {
    		// 예외발생 가능성이 있는 코드
    } catch (Exception1 e1) {
    		// Exception1이 발생한 경우 처리하기 위한 문장
    } catch (Exception2 e2) {
    		// Exception2이 발생한 경우 처리하기 위한 문장
    }
    ```
    
    - try 블럭에서 예외가 발생하면, 예외가 발생한 위치 이후에 있는 try 블럭들의 문장은 수행되지 않으므로, try블럭에 포함시킬 코드의 범위를 잘 선택해야 한다.
    
- printStackTrace( )와 getMessage( )
    
    예외가 발생했을 때 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨 있다. → 예외 발생 원인을 파악할 수 있다.
    
    - printStackTrace( ) : 예외발생 당시의 호출스택에 있었던 메서드의 정보와 예외 메시지를 출력
    - getMessage( ) : 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.
