### 지네릭스

다양한 타입의 객체를 다루는 메서드, 컬렉션에 입력 가능한 객체를 제한하게 하는 기능이다.

객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다. 타입의 안정성을 높인다는 것은 의도하지 않은 타입의 객체가 저장되는 것을 막고 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환되어 발생할 수 있는 오류를 줄여준다.

- 지네릭스의 장점
    
    1. 타입 안정성을 제공한다.
    
    2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.
    
- 지네릭스의 제한
    1. 모든 객체에 대해 동일하게 동작해야하는static 멤버에 타입  변수 T를 사용할 수 없다.
    2. 지네릭 타입의 배열을 생성하는 것도 허용되지 않는다.

### **지네릭 클래스의 객체 생성과 사용**

```java
class Box<T> {
		ArrayList<T> list = new ArrayList<T>();
		void add(T item) { list.add(item)} ;		
}
```

1. Box<T>의 객체를 생성할 때 참조변수와 생성자에 대입된 타입이 일치해야한다. 

```java
Box<Apple> appleBox = new Box<Apple>();  // OK
Box<Apple> appleBox = new Box<Grape>();  // 대입된 타입이 달라 에러발생
```

1. 두 지네릭 클래스의 타입이 상속관계이고, 대입된 타입이 일치하는 것은 가능하다. 

```java
// FruitBox가 Box의 자손인 경우
Box<Apple> appleBox = new FruitBox<Apple>();
```

1. 대입된 타입과 다른 타입의 객체는 추가할 수 없다.

- 제한된 지네릭 클래스

타입 매개변수 T에 지정할 수 있는 타입의 종류를 제한하기 위해서는 extends 키워드를 사용하면 특정 타입의 자손들만 대입할 수 있제 제한할 수 있다. 클래스가 아니라 인터페이스를 구현해야한다는 제약이 필요하다면 implements가 아닌 extends를 사용한다.

- 와일드 카드

< ? extends T>: 와일드 카드의 상한 제한, T와 그 자손들만 가능

<? super T>: 와일드 카드의 하한 제한, T와 그 조상들만 가능

<?>: 제한 없음. 모든 타입이 가능. <? extends Object>와 동일

- 지네릭 메서드

메서드 선언부에 지네릭 타입이 선언된 메서드를 지네릭 메서드라고 한다.

지네릭 타입의 선언 위치는 반환타입 바로 앞이다.

> **와일드 카드** : 하나의 참조변수로 서로 다른 타입이 대입된 여러 지네릭 객체를 다루기 위한 것
**지네릭 메서드** : 메서드를 호출할 때 마다 다른 지네릭 타입을 대입할 수 있게 한 것
> 

- 지네릭 타입의 제거

컴파일러는 지네릭 타입을 이용해서 소스파일을 체크하고, 필요한 곳에 형변환을 넣어준다.

그리고 지네릭 타입을 제거한다. (즉 컴파일된 (*.class) 에는 지네릭 타입에 대한 정보가 없다.)

이는 지네릭이 도입되기 이전의 소스코드와의 호환성을 유지하기 위해서이다. jdk1.5부터 지네릭스가 도입되었지만, 아직도 원시 타입을 사용해서 코드를 작성하는 것을 허용한다.

### Iterator<E>와 HashMap<K, V>

제네릭스가 적용되어 있는 클래스/인터페이스

### 1. Iterator

```java
// 기존 일반 Iterator 인터페이스
public interface Iterator {
	boolean hasNext();
    Object next();
    void remove();
}
// 제네릭스 적용 Iterator
public interface Iterator<E> { // 타입 변수 <E>
	boolean hasNext();
    E next(); // Object → E
    void remove();
}
```

Iterator에도 제네릭스가 적용될 수 있는데, 기존에 형변환을 해서 사용했던 것과는 달리 제네릭스가 적용되었기 때문에 형변환 과정이 필요없다.

```java
...
Iterator it = list.iterator();
while(it.hasNext()) {
	Student s = (Student)it.next() ; // 형변환이 필요했었음
}

ArrayList<Student> list = new ArrayList<Student>() ;
...
Iterator<Student> it = list.iterator(); //<E>에 Student 대입
while(it.hasNext()) {
	Student s = it.next() ; // 지네릭 클래스로 바뀌게 되면 타입이 일치되기 때문에 형변환이 필요없음
}
```

### 2. HashMap

HashMap은 키와 값의 형태로 저장하는 컬렉션 클래스인데 이 경우에는 지정해줘야 할 타입이 2개이다. 콤마 구분자를 통해 2개의 타입 모두 선언해주면 된다.

```java
/*
이렇게 HashMap클래스가 선언되어 있다.
*/
public class HashMap<K, V> extends AbstractMap<K, V> {
	...
    public V get(Object key) {...}
    public V put(K key, V value) {...} // 타입 K, V로
    public V remove(Object key) {...}
    ...
}

// ,를 통해 구분해서 Key 값은 String 타입, Value 값은 Student 타입을 대입한다.
HashMap<String, Student> map = new HashMap<String, Student>() ;
map.put("동규", new Student("동규", 24, 100,100,100)) ;

/*
아래와 같이 적용되어 작업을 수행
*/
public class HashMap extends AbstractMap<K, V> {
	...
    public Student get(Object key) {...}
    public Student put(String key, Student value) {...} // 타입 K, V로
    public Student remove(Object key) {...}
    ...
}
```

### **열거형 Enum**

열거형은 서로 관련된 상수를 편리하게 선언하기 위한 것으로 여러 상수를 정의할 때 사용하면 유용하다.

⇒ 자바의 열거형은 타입에 안전한 열거형이라서 실제 값이 같아도 타입이 다르면 컴파일 에러가 발생한다. (값 뿐만 아니라 타입까지 체크하기 때문에 타입에 안전하다)

> enum 열거형 이름  { 상수명1, 상수명2 ...}
> 

열거형 상수간의 비교에는 == 을 사용할 수 있다. 

( equals가 아닌 ==로 비교가 가능하다는 것은 그만큼 빠른 성능을 제공한다)

그러나 비교연산자는 사용할 수 없고, compareTo()를 사용해야 한다.

Enum 클래스에 정의된 ordinal()이 열거형 상수가 정의된 순서를 반환하지만, 이 값은 내부적인 용도로만 사용되기 위한 것이기 때문에 이 값을 열거형 상수의 값으로 사용하지 않는 것이 좋다.

### **애너테이션 annotation**

애니테이션이란 주석처럼 프로그래밍 언어에 영향을 미치지 않으며 유용한 정보를 제공하는 것이다.

자바를 개발한 사람들은 소스코드에 대한 문서를 따로 만들기보다 소스코드와 문서를 하나의 파일로 관리하는 것이 낫다고 생각하여 주석 /** ~ */ 에 소스코드에 대한 정보를 저장하고, 소스코드의 주석으로부터 html문서를 생성해내는 프로그램 javadoc.exe를 만들어 사용했다.

/** 로 시작하는 주석 안에 소스코드에 대한 설명들이 있고 그 안에 '@'이 붙은 태그들을 이용해서 주석 안에 정보를 제공하고 javadoc.exe라는 프로그램이 이 정보를 읽어서 문서를 작성하는데 사용한다. 이 기능을 응용하여 프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이 바로 애너테이션이다.

애터네이션이 주석처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공할 수 있다는 장점이 있다.
