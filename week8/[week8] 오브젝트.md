(1장부터 9장까지 읽었는데 중복된 부분이 좀 많아서 일부 챕터는 설명을 생략했습니다)

# 4장 설계 품질과 트레이드 오프

> 상태 중심의 설계가 나쁜 이유
> 

## 훌륭한 설계의 기준

훌륭한 설계란 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만다는 것이다. 객체지향 커뮤니티에서 논의한 좋은 설계의 기준은 캡슐화, 응집도, 결합도이다. 데이터 중심 설계는 이 세 가지 기준에서 책임 중심 설계보다 좋지 않다.

## 데이터 중심 설계의 한계

데이터 중심 설계는 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할한다. 데이터 중심 설계를 따른 객체들은 구현에 의존하기 때문에 결합도가 높은 설계가 낭로 수 밖에 없다. 

구현에 의존한다는 것은 캡슐화를 위반하고 객체 내부 구현을 인터페이스로 만든다. 내부 구현을 드러내면 클라이언트가 구현에 강하게 결합되고, 객체의 내부 구현을 변경하면 인터페이스에 의존하는 모든 클라이언트도 변경된다. 응집도가 낮고 결합도가 높은 객체들을 양산하게 될 가능성이 높다. 



# 6장 메시지와 인터페이스

> 유연하고 재사용 가능한 퍼블릭 인터페이스 설계 원칙과 기법
> 

## 객체의 품질을 결정하는 메시지

객체의 퍼블릭 인터페이스는 객체의 품질을 결정한다. 메시지는 객체의 퍼블릭 인터페이스와 그 안에 포함될 오퍼레이션을 결정한다.

메시지는 객체 간의 협력을 위한 의사소통 매커니즘이다. 전송자와 수신자를 포함한다. 오퍼레이션은 객체가 다른 객체에게 제공하는 추상적인 서비스로, 메시지 수신자의 인터페이스를 강조한다. 메서드는 메시지에 응답하기 위해 실행되는 코드이고 오퍼레이션의 구현이다. 

## 좋은 인터페이스의 조건

좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야한다. 꼭 필요한 오퍼레이션만 인터페이스에 포함하고, 무엇을 하는지 표현한다. 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지할 수 있다. 메시지가 객체를 선택하게 함으로써 클라이언트의 의도를 메시지에 표현할 수 있다.

## 디미터

객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다. 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.

클래스 내부 메소드는 아래 조건을 만족하는 인스턴스에만 메시지를 전송해야 한다. 

- this 객체
- this 속성
- this 속성인 컬렉션의 요소
- 메서드 매개변수
- 메서드 내에서 생성된 지역 객체

기차 충돌은 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태로, 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 된다. 캡슐화를 위반했다는 코드 스멜이다.

## 묻지 말고 시켜라

묻지 말고 시켜라는 디미터 법칙 스타일의 메시지 작성을 장려하는 원칙이다. 메시지 전송자는 메신자 수신자의 상태를 기반으로 결정을 내리고 메시지 수신자의 상태를 변경해서는 안된다. 호출하는 객체는 이웃 객체가 수행하는 역할을 사용해 무엇을 원하는지 서술해야하고, 호출되는 객체가 어떻게 해야 하는지를 스스로 결정하게 한다.

## 의도를 드러내는 인터페이스

클라이언트의 의도가 분명하게 드러나도록 객체의 인터페이스를 개선해야 한다. `수신자.메시지()` 코드는 다음과 같이 해석해야 한다. `수신자야 (메소드명) 좀 해줘~`

## 명령 쿼리 분리

객체의 상태를 변경하는 명령은 반환값을 가질 수 없다. 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다. 명령은 부수효과를 가지고, 쿼리는 부수효과를 가지지 않는다. 이 원칙은 코드의 부수효과를 관리해서 참조 투명성의 장점을 제한적으로나마 누리기 위해 존재한다. 

참조 투명성은 부수효과가 없는 불변의 세상에서 동일한 입력에 대해 항상 동일한 값을 반환하는 특성이다. 참조 투명성은 불변하는 값을 가지므로 함수식을 쉽게 대체할 수 있고 순서를 변경할 수 있다. 객체지향 패러다임은 객체의 상태 변경이라는 부수효과를 기반으로 하지만, 명령과 쿼리를 분리하면 참조 투명성을 제한적으로 누릴 수 있다.



# **8장 의존성 관리하기**

> 협력적이면서도 유연한 객체을 만들기 위한 의존성 관리 방법
> 

## 의존성 이해하기

의존성은 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성이다. 의존성은 협력을 위해 반드시 필요하다. 하지만 의존성은 전이되므로 변경에 영향을 미친다. 유연하고 재사용 가능한 코드를 설계하려면 동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 한다. 그러려면 클래스는 문맥으로부터 독립적이어야 한다. 이때 구체적인 문맥은 컴파일타임 의존성을 런타임 의존성으로 어떻게 대체하느냐에 달려있는데, 의존성 해결을 통해 달성할 수 있다.

## 의존성 관리 방법

의존성 관리의 핵심은 불필요한 의존성은 제거하고 필요한 의존성은 명시적으로 드러내는 것이다. 바람직한 의존성은 컨텍스트에 독립적이어서 재사용을 쉽게 허용하고, 바람직하지 않은 의존성은 컨텍스트에 강하게 결합되어 재사용하려면 코드를 수정할 수 밖에 없게 한다. 재사용이 가능한 의존성은 구체가 아닌 추상화에 의존한다. 클라이언트가 전송하는 메시지를 이해할 수 있다면 어떤 타입의 객체와 협력해도 상관이 없다.

# 9장 유연한 설계

> 주제 : 의존성 관리 기법을 원칙으로 설명하기
> 

## OCP

유연한 설계는 기존의 코드를 수정하지 않고 애플리케이션의 동작을 확장할 수 있어야 한다. 컴파일 타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정하면 된다. 

추상화에 의존함으로써 달성할 수 있다. 변하지 않는 부분을 고정하고 변하는 부분은 생략하는 추상화를 적용하고, 모든 요소가 추상화에 의존하도록 하면 수정에 대한 영향을 최소화할 수 있다.

## 생성 사용 분리

객체 생성에 대한 지식은 과도한 결합도를 초래하므로, 객체 생성 책임은 사용 책임으로부터 분리하는 것이 좋다. 객체 생성 책임을 현재 컨텍스트를 가지고 있는 클라이언트로 옮기거나, 객체 생성 책임만을 가지는 Factory 객체를 추가한다.

## Pure Fabrication 패턴

객체지향 설계는 문제 도메인 상의 개념을 소프트웨어 객체로 구현하고 책임을 할당한다. 하지만 만약 도메인 객체에 책임을 할당할 경우 결합도가 높아지거나 응집성이 높아지거나 재사용이 어려워질 수 있다. 이때는 가공의 객체를 추가해서 책임을 옮기면 전체 설계의 품질을 높일 수 있다. 순수한 인공물 객체는 도메인에 책임을 할당하는 표현적 분해와 대조되는 행위적 분해이다.

## 의존성 주입

생성과 사용을 분리하면 사용 책임만 남은 객체는 외부로부터 생성된 인스턴스를 전달 받아야한다. 이를 의존성 해결이라고 하는데, 의존성 주입은 명시적으로 의존성을 해결하는 방법이다. 

생성자, 수정자, 메소드, 인터페이스를 통해 의존성을 주입할 수 있다. 생성자로 주입된 의존성은 생명주기 전체에서 유지되고 의존성을 명시할 수 있다.(생성자 부분만 보면 됨) 수정자는 생명주기 도중에 의존성을 변경할 수 있지만, 의존성이 명시적이지 않다. 메소드는 인자로 의존성을 넘겨주는 방법인데 메소드 안에서만 의존성이 필요할 때 사용한다. 인터페이스는 수정자나 메소드 주입의 명시성을 보완한다.

명시적으로 의존성을 해결하는 의존성 주입은 캡슐화를 잘 지키는 방법이다. 필요한 의존성이 클래스의 퍼블릭 인터페이스에 드러나므로 코드 내부를 읽을 필요가 없다. 반면 의존성을 숨기는 service locator 패턴은 코드를 이해하기도 수정하기도 어려워진다. 의존성을 드러내야하는 이유는 이것이 캡슐화를 지킬 수 있는 방법이기 때문이다.

## 의존성 역전 원칙

의존성 역전 원칙은 전통적인 패러다임이 고수하는 의존성 방향을 역전시킨다. 전통적인 패러다임은 상위 모듈이 하위 모듈에 의존한다. 객체지향 패러다임은 상의 모듈과 하위 모듈이 모두 추상화에 의존한다. 추상화는 구체적인 사항에 의존하지 않으며 구체적인 사항은 추상화에 의존한다. 인터페이스도 상위 수준 모듈에 속하게 되어 모듈을 배포할 때 불필요한 구현 파일을 포함하지 않아도 된다.

## 유연성 조언

설계가 유연할수록 클래스 구조와 객체 구조 사이의 거리는 점점 멀어진다. 유연성은 재사용 가능한 설계를 만들지만 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때 가치가 있다. 설계의 미덕은 단순함과 명확함에서 나온다.

설계를 유연하게 만들기 위해서는 먼저 역할, 책임, 협력에 초점을 맞춰야 한다. 다양한 컨텍스트에서 협력을 재사용할 필요가 없다면 설계를 유연하게 만들 당위성이 사라진다.
