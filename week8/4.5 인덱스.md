## 4.5 인덱스

---

### 4.5.2 B-Tree

- 인덱스는 보통 B-Tree 자료 구조로 이루어져 있음
- 루트 노드 → 브랜치 노드 → 리프 노트
- 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수 확장성 존재
- 인덱스가 한 깊이씩 증가할 때 마다, 최대 인덱스 항목의 수는 4배씩 증가

### 4.5.3 인덱스 만드는 방법

- `MySQL`
    - 클러스터형 인덱스
        - 테이블당 하나 설정 가능
        - `Primary key` 옵션으로 기본 키로 생성
        - `Unique not null` 옵션을 붙여 생성
        - 하나의 인덱스만 생성 시에 유리
    - 세컨더리 인덱스
        - `create index` → 명령어를 기반으로 생성
        - 보조 인덱스로, 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 유리
- `MongoDB`
    - 도큐먼트 생성 시 자동으로 ObjectID 형성 → 기본 키로 설정
    - 기본 키 + 세컨더리 키 = 복합 인덱스 설정 가능

### 4.5.3 인덱스 최적화 기법

- 인덱스는 비용이다
    - (1) 두 번 탐색하도록 강요
        - `인덱스 리스트 → 컬렉션 순으로 두번 탐색` ⇒ 그렇기 때문에 읽기 관련 비용이 더 들게 됨
    - (2) 컬렉션 수정 시 인덱스도 수정
        - B-Tree 높이 조절 비용, 데이터 분산 구축 비용 존재
    - ⇒ 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것이 정답 아님
    - ⇒ 컬렉션에서 가져와야 하는 양이 많을수록 인덱스 사용하는 것은 비효율적
- 항상 테스팅하라
    - 서비스에 따라 인덱스 최적화 기법이 달라지기 때문에 테스팅하는 것이 중요
    - `explain() 함수`
        - 인덱스를 만들고 쿼리를 보낸 이후 테스팅하며 걸리는 시간을 최소화 해야함
- 복합 인덱스는 같음>정렬>다중값>카디널리티 순
    - `같음을 비교하는 쿼리`가 있다면, 제일 먼저 인덱스로 설정
    - 그 다음엔 `정렬`에 쓰는 필드를 인덱스로 설정
    - 쿼리 자체가 >, < 등 `많은 값을 출력해야하는 쿼리`에 쓰이는 필드라면 나중에 인덱스 설정
    - `카디널리티`(=유니크한 값의 정도) 가 높은순으로 인덱스 생성
