## 3.2 메모리

---

### 3.2.1 메모리 계층

|  | 개념 | 특징 |
| --- | --- | --- |
| 레지스터 | CPU 안에 있는 작은 메모리 | 휘발성, 속도 가장 빠름, 기억 용량 가장 적음 |
| 캐시 | L1, L2, L3 | 휘발성, 속도 빠름, 기억용량 적음 |
| 주기억장치 | RAM | 휘발성, 속도 보통, 기억용량 보통 |
| 보조기억장치 | HDD, SSD | 비휘발성, 속도 낮음, 기억 용량 많음 |

- 캐시
    - 개념
        - 데이터를 미리 복사해 놓는 임시 저장소
        - 계층과 계층 사이에 있는 계층
    - 특징
        - 속도 차이로 인한 병목 현상을 줄이기 위한 메모리
        - 데이터를 접근하는 시간이 오래 걸리는 경우 해결
        - 다시 계산하는 시간 절약
    - 지역성의 원리
        - 시간지역성 : 최근 사용한 데이터를 다시 접근
        - 공간지역성 : 최근 접근한 데이터의 주변 공간에 접근

- 캐시히트와 캐시미스
    - 캐시매핑
        - 캐시가 히트되기 위해 매핑하는 방법
        - 분류
            - `직접 매핑` : 순서대로 캐시와 메모리 매핑하는 방법
            - `연관 매핑` : 순서를 일치시키지 않고 관련 있는 캐시와 메모리 매핑
            - `집합 연관 매핑` : 직접매핑 + 연관 매핑 (순서는 일치시키지만 집합을 둬서 저장하며 블록화)
        - 종류
            - `쿠키`
                - 만료기한이 있는 키-값 저장소
                - 4KB 까지 데이터 저장
                - 만료기간 정할 수 있음
                - httponly option : 쿠키를 볼 수 없게 함
                - 클라이언트 또는 서버에서 만료기한 수정 가능
            - `로컬 스토리지`
                - 만료기한이 없는 키-값 저장소
                - 10MB 까지 데이터 저장
                - 웹 브라우저를 닫아도 유지
                - 웹 브라우저에서 사용 불가 + 클라이언트에서만 수정 가능
            - `세션 스토리지`
                - 만료기한이 없는 키-값 저장소
                - 5MB 까지 데이터 저장
                - 탭을 닫을 때 해당 데이터 삭제
                - 웹 브라우저 사용 불가 + 클라이언트에서만 수정 가능

### 3.2.2 메모리 관리

- 가상 메모리
    - 가상 주소와 실제 주소 매핑하는 메모리 관리 기법
    - 컴퓨터가 실제로 이용 가능한 메모리 자원 추상화
    - **`메모리관리장치(MMU)`** : 가상 주소 → 실제 주소로 변환
    - **`페이지 테이블`** : 프로세스의 주소 정보가 들어있는 곳
    - **`TLB`** : 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시

- 스와핑
    - 메모리에서 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 쓰는 것
    - 페이지 폴트가 일어나지 않은 것처럼 만듬

- `페이지 폴트`
    - 프로세스의 주소 공간에는 존재하지만 현재 RAM에는 없는 데이터에 접근했을 경우 발생

- `스레싱`
    - 메모리의 페이지 폴트율이 높은 것
    - 메모리에 과도한 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나면서 발생
    - 페이지폴트 발생 → CPU 이용률 낮아짐 → 가용성을 높이기 위해 더 많은 프로세스를 메모리에 올림 → 악순환
    - 해결방법
        - **`작업세트`** : 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는 것
        - **`PFF(Page Fault Frequency)`** : 페이지 폴트 빈도의 상한선과 하한선을 만드는 방법

- 메모리할당
    - 연속할당
        - `고정 분할 방식`
            - 메모리를 미리 분할하여 관리하는 방식
            - 내부 단편화 발생 O
        - `가변 분할 방식`
            - 매 시점 프로그램의 크기에 맞게 동적으로 메모리 분할
            - 내부 단편화 발생 X, 외부 단편화 발생 O
            - 최초적합, 최적적합, 최악접합
                - 최초적합 : 위쪽이나 아래쪽부터 시작하여 메모리 공간 발견 후 바로 할당
                - 최적적합 : 가장 작은 메모리 공간부터 할당
                - 최악적합 : 프로세스 크기와 가장 차이가 많이 나는 메모리 공간에 할당
    - 불연속할당
        - 페이징 기법
            - 동일한 크기의 페이지 단위로 나눔
            - 메모리의 서로 다른 위치에 프로세스 할당
            - 주소 변환이 복잡해진다는 단점
        - 세그멘테이션
            - 의미 단위인 세그먼트로 나누는 방식
            - 메모리 공간이 균일하지 않다는 단점
        - 페이지드 세그멘테이션
            - 프로그램을 의미 단위인 세그먼트로 나눔
            - 공유나 보안 측면에 강점
            - 임의의 길이가 아닌 동일한 크기의 페이지 단위로 나누는 것

⚠️ 프로세스를 이루는 메모리 = `코드 영역` + `데이터 영역` + `스택 영역` + `힙 영역`

- 페이지 교체 알고리즘
    - 스와핑이 많이 일어나지 않도록 페이지 교체 알고리즘 설계
    - `오프라인 알고리즘`
        - 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꿈
        - 사용할 수 없지만 성능 비교에 대한 상한 기준 제공
    - FIFO (First In First Out)
        - 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법
    - `LRU (Least Recently Used)`
        - 참조가 가장 오래된 페이지를 바꾸는 방법
        - 해시테이블과 이중 연결 리스트로 구현
        - 각 페이지마다 계수기, 스택을 둬야하는 문제 존재
    - `NUR (Not Used Recently)`
        - clock 알고리즘이라고도 함
        - 1 (=최근에 참조), 0(=참조되지 않음) 비트 존재
        - 시계 방향으로 돌면서 0을 찾음
        - 0을 찾은 순간 해당 프로세스 교체 후 1로 바꿈
    - `LFU(Least Frequently Used)`
        - 가장 참조 횟수가 적은 페이지 교체
        - 많이 사용되지 않은 것 교체
