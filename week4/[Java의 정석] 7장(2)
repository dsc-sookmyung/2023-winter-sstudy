## 제어자

1. 제어자란?
    
    클래스, 변수, 메서드의 선언부에 사용 → 부가적의미 부여
    
    - 접근 제어자 : public, protected, default, private
    - 그외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
    
    주로 클래스나 멤버변수와 메서드에 사용됨.
    
2. static
    
    `클래스의`, `공통적인`
    
    - 클래스변수는 인스턴스에 관계없이 같은 값 가짐 → 하나의 변수를 모든 인스턴스가 공유하기 때문
    - static이 붙은 멤버변수와 메서드, 초기화 블럭 → 인스턴스를 생성하지 않고도 사용할 수 있음
    - static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭
        - 멤버변수 : 모든 인스턴스에 공통적으로 사용됨, 메모리에 로드될 때 생성됨
        - 메서드 : 인스턴스 생성하지 않고도 호출 가능, 메서드 내에서 인스턴스 멤버들 직적 사용 불가

1. final
    
    마지막의, 변경될 수 없는
    
    - 거의 모든 대상에 사용
        - 멤버변수, 지역변수 : 값 변경 할 수 없는 상수
        - 메서드 : 오버라이딩 할 수 없음 = 변경할 수 없는 메서드
        - 클래스 : 자손클래스 정의 x= 확장할 수 없는 클래스 = 변경 될 수 없는 클래스
        
2. 생성자를 이용한 final 멤버 변수 초기화
    - 인스턴스변수의 경우 생성자에서 초기화되도록 할 수 있음
    - 클래스 내에 메개변수를 갖는 생성자를 선언→ 인스턴스를 생성할 때 final이 붙은 멤버변수를 초기화하는데 필요한 값을 생성자의 매개변수로부터 제공받는 것

1. abstract
    
    추상의, 미완성의
    
    - 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용됨
    - 클래스에 사용되어 추상메서드 존재여부를 알 수 있게 함
        - 클래스 : 클래스 내에 추상 메서드가 선언되어 있음을 의미
        - 메서드 : 선언부만 작성하고 구현부는 작성하지 않은 추상메서드임을 알림

1. 접근제어자
    - 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할
    - 접근 제어자가 사용될 수 잇는 곳 - 클래스, 멤버변수, 메서드, 생성자
        - private : 같은 클래스 내에서만 접근가능
        - default : 같은 패키지 내에서만 접근가능
        - protected : 같은 패키지내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능
        - public : 접근 제한이 전혀 없음
    - 범위 : public > protected > (default) > private
    
    - 접근 제어자를 이용한 캡슐화
        
        > 데이터 감추기, 캡슐화
        > 
        - 접근제어자 → 클래스의 내부에 선언된 데이터를 보호하기 위해서 사용
        - 데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 변경하지 못하도록 외부로부터의 접근을 제한하는 것이 필요
        - 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

- 생성자의 접근제어자
    - 인스턴스의 생성을 제한
    - 보통 생성자의 접근 제어자는 클래스의 접근 제어자와 같지만, 다르게 지정할 수도 있다

## 다형성

1. 다형성이란?
    
    : 여러 가지 형태를 가질 수 있는 능력
    
    - 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다는 것
    - 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있음
    - 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없음
    - 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야함

1. 참조변수의 형변환
    - 서로 상속관계에 있는 클래스사이에서만 가능 → 자손타입과 조상타입 서로간의 형변환만 가능
        - 자손타입 -> 조상타입(up-casting) : 형변환 생략가능
        - 조상타입 -> 자손타입(down-casting) : 형변환 생략불가
    
    `형변환`
    
    - 참조변수의 타입을 반환하는 것
    - 인스턴스를 변환하는 것은 아님
    - 참조변수의 형변환 → 인스턴스에 아무런 영향을 미치지 않음
        - 참조하고 있는 인스턴스에서 사용할 수 잇는 멤버의 범위(개수)를 조절하는 것
    - 상속관계에 있는 타입간의 형변환:
        - 양방향으로 자유롭게 수행될 수 있음
        - 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않음
    - 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요
    
    1. instanceof 연산자  
        
        참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
        
        - 주로 조건문에 사용
        - 참조변수 + instaceof + 타입(클래스명)
        - 연산자 결과 : true , false
    
    1. 참조변수와 인스턴스의 연결
        - 멤버변수가 조상클래스와 자손클래스에 중복으로 정의된 경우
            - 조상타입의 참조 변수 사용 → 조상클래스에 선언된 멤벼변수 사용됨
            - 자손타입의 참조 변수 사용 → 자손클래스에 선언된 멤버변수 사용됨
        - 조상 클래스의 메서드를 자손의 클래스에서 오버라이딩한 경우
            - 참조변수의 타입에 관계없이 항상 실제인스턴스의 메서드(오버라이딩된 메서드)가 호출
        - 멤버변수의 경우 참조변수의 타입에 따라 달라짐
    
    1. 여러 종류의 객체를 배열로 다루기
        
        조상타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있음
        
        ### Vector
        
        : 동적으로 크기가 관리되는 객체배열
        
        - Vector() : 10개의 객체를 저장할 수 있는 Vector인스턴스를 생성, 자동 크기 증가
        - boolean add(Object o)
        - boolean remove(Object o)
        - boolean isEmpty()
        - Object get(int index) : 지정된 위치(index)의 객체를 반환, 반환타입이 Object타입이므로 적절한 타입으로의 형변환이 필요
        - int size()
    
    ## 추상클래스
    
    1. 추상클래스란?
    
    : 미완성 메서드(추상메서드)를 포함하고 있는 클래스
    
    - 인스턴스를 생성할 수 없으며, 상속을 통해서 자손클래스에 의해서만 완성될 수 있음
    - 키워드 'abstract'를 붙이기만 하면 됨 → 'abstract'를 보고 이클래스에는 추상메서드가 있으니 상속을 통해서 구현해주어야 한다는 것을 쉽게 알 수 있음
    - 추상메서드를 포함하고 있다는 것을 제외하고는 일반클래스와 전혀 다르지 않음
        - 추상클래스에도 생성자가 있으며, 멤버변수와 메서드도 가질 수 있음
    
    2. 추상메서드(abstract method)
    
    : 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것
    
    = 설계만 해놓고 실제 수행될 내용은 작성하지 않았기 때문에 미완성 메서드
    
    `abstract 리턴타입 메서드이름();`
    
    - 추상클래스로부터 상속받는 자손클래스 :
        - 오버라이딩을 통해 조상인 추상클래스의 추상메서드를 모두 구현
    - 조상으로부터 상속받은 추성메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 함
    
    3. 추상클래스의 작성
    
    - 여러 클래스에 공통적으로 사용될 수 있는 클래스를 바로 작성 or 기존의 클래스의 공통적인 부분을 뽑아서 추상클래스로 만들어 상속하도록
    - 추상화 : 기존의 클래스의 공통부분을 뽑아내 조상클래스를 만드는 것
    
    **추상화 vs 구체화**
    
    - 추상화 - 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업
    - 구체화 - 상속을 통해 클래스를 구현, 확장하는 작업
    
    ## 인터페이스(interface)
    
    1. 인터페이스란?
    
    인터페이스는 일종의 추상클레스
    
    - 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높음 → 몸통을 갖춘 일반메서드 또는 멤버변수를 구성원으로 가질 수 없음
    - 오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용하지 않음
    
    `추상클래스` - 미완성 설계도
    
    `인터페이스` - 기본 설계도
    
    1. 인터페이스의 상속
    - 인터페이스는 인터페이스로부터만 상속받을 수 있음
    - 클래스와는 달리 다중상속, 즉 여러개의 인터페이스로부터 상속을 받는 것이 가능
    - 자손인터페이스는 조상인터페이스에 정의된 멤버를 모두 상속받는다.
    
    **[인터페이스는 클래스와 달리 Object클래스와 같은 최고조상이 없다.]**
    
    1. 인터페이스의 구현
    - 그 자체로는 인스턴스를 생성할 수 없음
    - 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 함
        - 클래스의 확장 키워드 'extends'처럼 인터페이스는 구현한다는 키워드 'implements'를 사용
    - 만일 구현하는 인터페이스의 메서드 중 일부만 구현한다면 abstract를 붙여 추상클래스로 선언
    
    4. 인터페이스의 장점
    
    - 개발시간을 단축시킬 수 있다.
    - 표준화가 가능하다.
    - 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
    - 독립적인 프로그래밍이 가능하다.
    
    1.  인터페이스의 이해
    - 클래스를 사용하는 쪽(User)과 제공하는 쪽(Provider)이 있음
    - 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 됨(내용은 몰라도 됨)
    1. 디폴트 메서드와 static메서드
    - 디폴트 메서드
        - 디폴트 메서드는 앞에 default를 붙임
        - 추상 메서드와 달리 일반 메서드처럼 몸통{}이 있어야함
        - 디폴트 메서드 역시 접근 제어자가 public이며, 생략 가능
    
    ## 내부 클래스(inner class)
    
    클래스 내에 선언된다는 점을 제외하고는 일반적인 클래스와 다르지 않으며, 몇가지 특징만이 별도로 존재한다.
    
    1. 내부 클래스란?
    
    내부 클래스는 클래스 내에 선언된 클래스
    
    두 클래스가 서로 긴밀한 관계에 있을 때 이렇게 선언할 것을 고려
    
    1. 내부 클래스의 장점
        - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있음
        - 코드의 복잡성을 줄일 수 있음(캡슐화)
    
    3. 내부 클래스의 종류와 특징
    
    내부 클래스의 종류는 변수의 선언위치에 따른 종류와 같음
    
    - 인스턴스 클래스(instance class)
        - 외부 클래스의 멤버변수 선언위치에 선언
        - 외부 클래스의 인스턴스 멤버처럼 다루어짐
        - 주로 외부 클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적으로 선언됨
    - 스태틱 클래스(static class)
        - 외부 클래스의 멤버변수 선언위치에 선언
        - 외부 클래스의 static멤버처럼 다루어짐
        - 주로 외부 클래스의 static멤버, 특히 static메서드에서 사용될 목적으로 선언됨
    - 지역 클래스(local class)
        - 외부 클래스의 메서드나 초기화블럭 안에 선언
        - 선언된 영역 내부에서만 사용될 수 있음
    - 익명 클래스(anoymous class)
        
        클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스 (일회용)
        
    
    4. 내부 클래스의 제어자와 접근성
    
    인스턴스클래스와 스태틱 클래스는 외부 클래스와 멤버변수(인스턴스변수와 클래스변수)와 같은 위치에 선언
    
    - 멤버변수와 같은 성질을 갖음 → 따라서 내부 클래스가 외부 클래스의 멤버와 같이 간주되고, 인스턴스멤버와 static멤버 간의 규칙이 내부 클래스에도 똑같이 적용됨
    - 내부 클래스도 클래스이기 때문에 abstract나 final과 같은 제어자를 사용할 수 있을 뿐만 아니라, 멤버변수들처럼 private, protected와 접근제어자도 사용이 가능
    - 내부 클래스와 외부 클래스에 선언된 변수의 이름이 같을 땐 변수 앞에 'this' 또는 '외부 클래스명 ’this'를 붙여 서로 구별할 수 있음
    
    5. 익명 클래스(anonymous class)
    
    - 다른 내부 클래스들과는 달리 이름이 없음
    - 오직 하나의 객체만을 생성할 수 있는 일회용 클래스
    - 생성자를 가질 수 없으며, 하나의 클래스를 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스도 구현할 수 없음
    - 단 하나의 클래스를 상속받거나 인터페이스를 구현할 수 있음
